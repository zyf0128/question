# JVM面试题

##### 1 简述: 内存模型以及分区,需要详细到每个区放什么.

<img src="E:\desk\zhuyin\面试题\jvm面试题\img\jvm模型.png" alt="1651237576153" style="zoom:80%;" />

- jvm 分为堆区,栈区(虚拟机栈)和方法区(元空间 meta ),PC寄存器(操作数栈).
- 初始化的对象放在堆里面,引用放在栈里面,class类信息,常量池(static常量和static变量)等放在方法区.
- 方法区: 主要是存储类信息,常量池,编译后的代码(字节码文件)等数据.
- 堆区:  初始化的对象,成员变量(非静态变量) , 所有的实例对象和数组都要在堆上分配.
- 栈区: 栈的结构是栈帧组成的.调用一个方法就压入一帧,帧上面存储局部变量表,操作数栈,方法出口等信息. 局部变量表存放的是 8 大 基础类型加上一个引用类型,所以还是指向地址的指针.
- 本地方法栈: 主要为 Native 方法服务
- 程序计数器: 记录当前线程执行的行号

##### 2 简述:堆里面的分区: Eden, survival( from + to),老年代, 各自的特点.

- 堆里面分为新生代和老生代(java8 取消了永久代,采用了 Metaspace ), 新生代包含 Eden + survival 区,  survival 区里面 分为from 和 to 区 
- 内存回收时,如果用的是复制算法, 就会从 from 复制到 to ,但经过一次或者多次 `GC(垃圾清理)` 之后,存活下来的对象会被移动到老年区
- 当`Jvm 内存不够用`的时候,会触发 `Full GC`, 清理Jvm 老年区
- 当`新生区满了之后`会触发` YGC` , 先把存活起来的对象放到其中一个Survice区,然后进行垃圾清理.
- 注意: `如果仅仅清理需要删除的对象,这样会导致内存碎片`,因此一般会把Eden 进行完全的清理,然后整理内存.那么下一次GC的时候,就会使用下一个 Survice 这样循环使用 
- 如果有特别大的对象，新生代放不下， 就会使用老年代的担保，直接放到老年代里面。因为JVM 认为，一般大对象的存活时间一般比较久远.

##### 4 GC 的两种判定方式

1. 引用计数法:

   - 指的是如果某个地方`引用了这个对象就 +1` , 如果`失效了就 -1`,当为 0 就回收. 但是jvm没有使用这种方式,因为无法判定互相循环引用的情况 :

     `A 引用了 B, B引用了A` 

2. 引用链法

   - 通过一种`GC ROOT`的对象（方法区中静态变量引用的对象等-static变量）来判断，如果`有一条链能够到达GC ROOT`就说明`不能回收`，`不能到达GC ROOT`就说明`可以回收 `

##### 5 SafePoint是什么?

- Jvm 在进行 GC 的时候必须要等到Java线程都进入到 safepoint 的时候 VMThread 才能开始执行GC
- 1. 循环的末尾 (防止大循环的时候一直不进入safepoint，而其他线程在等待它进入safepoint) 
  2. 方法返回前  
  3. 调用方法的call之后 
  4.  抛出异常的位置 

##### 6. GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？

- 标记清除:  先标记，标记完毕之后再清除，效率不高，会产生碎片
- 复制算法：分为8 ：1的Eden区和 survival 区，就是上面谈到的 YGC (先把存活起来的对象放到其中一个Survice区,然后进行垃圾清理.)
- 标记整理：标记完毕之后，让所有存活的对象向一端移动  

##### 7, GC收集器有哪些？CMS收集器与G1收集器的特点?

- 串行收集器：串行收集器使用一个单独的线程进行收集，GC时服务有停顿时间 
- 并行收集器：次要回收中使用多线程来执行 
- CMS收集器是基于“标记—清除”算法实现的，经过多次标记才会被清除 
- G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的

###### 8, Minor GC ( 新生代垃圾清理) 与 Full GC分别在什么时候发生？ 

- 新生代内存不够用时候发生MGC 也叫 YGC
- JVM 内存不够的时候发生FGC  (FULL GC) 

##### 9,  几种常用的内存调试工具：jmap、jstack、jconsole、jhat 

- jstack可以看当前栈的情况

- jmap查看内存，

- jhat 进行dump堆的信息 

  

##### 10, 类加载的几个过程：

- 加载、验证、准备、解析、初始化。然后就是 使用 和 卸载了 
- 通过全限定名来`加载`生成 class对象到内存中，
- 然后进行`验证`这个class文件，包括文件格式校验、元数据验证，字节码校验等。
- `准备`: 是对这个对象分配内存。
- `解析`: 是将符号引用转化为直接引用（指针引用）
- `初始化`: 就是开始执行构造器的代码 

##### 11, JVM内存分哪几个区，每个区的作用是什么? 

- 方法区： 

  - 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载 
  - 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
  - 该区域是被线程共享的。 
  - 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

- 虚拟机栈: 

  1. 虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。 
  2. 虚拟机栈是线程私有的，它的生命周期与线程相同。 
  3. 局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定 
  4. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式 
  5. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。 

  

- 本地方法栈: 

  本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native方法服务。

- 堆 : java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。 

- 程序计数器 内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域

##### 12.如何判断一个对象是否存活?(或者GC对象的判定方法)

1. 引用技术法
   - 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.
   - 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
2. 引用链法
   - 该算法的思想是：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。
   - 在java中可以作为GC Roots的对象有以下几种: 
     - 虚拟机栈中引用的对象 
     - 方法区类静态属性引用的对象  
     - 方法区常量池引用的对象 
     - 本地方法栈JNI引用的对象 
   - 虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。
     - 当一个对象不可达 GC Root时，这个对象并不会立马被回收，而是处于一个`死缓的阶段`，若要被真正的回收需要经历两次标记 
     - 如果对象在可达性分析中没有与GC Root的引用链，那么此时就会`被第一次标记并且进行一次筛选`
     - `筛选的条件` : 是否有必要执行 finalize()方法。
       - 当对象没有覆盖 finalize() 方法 或者 已被虚拟机调用过，那么就认为是没必要的。
       - 如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的对队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。



##### 13, 简述java垃圾回收机制?

- 在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。
- 在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，清理那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。 

14, java中垃圾收集的方法有哪些?

`标记-清除`: 这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：

1. 效率不高，标记和清除的效率都很低；
2. 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。

`复制算法`: 

- 为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，`每次基本上都要浪费一半的内存`。 
- 于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为`8:1:1`三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。
- 每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代) 

`标记-整理` 

- 该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候先将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。

`分代收集`

- 现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存期，将堆分为新生代和老年代。
- 在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。
- 老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用 `标记-整理` 或者 `标记-清除`。

##### 15,  java内存模型

- Java内存模型 (JMM) 是线程间通信的控制机制.

- JMM定义了 主内存和 线程之间抽象关系。
- 线程之间的 共享变量存储在主内存（main memory）中，
- 每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。
- 本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器 以及其他的硬件和编译器优化

##### 16 java类加载过程? 

Java类加载需要经历一下7个过程： 

`加载` 

加载 是类加载的第一个过程，在这个阶段，将完成一下三件事情： 

1. 通过一个类的全限定名获取该类的二进制流。 
2. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 
3. 在内存中生成该类的Class对象，作为该类的数据访问入口。 

`验证`: 

验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: 

1. 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. 
2. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。 
3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。 
4. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。 

`准备` 

准备阶段 : 是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。  `public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。`

`解析` 该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。 

`初始化` 初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义Java程序代码。 

##### 17, 简述类加载机制

- 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型

##### 18,简述类加载器双亲委派模型机制？

- 当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

##### 19, 什么是类加载器,类加载器有哪些?

`类加载器 `: 实现 通过类的全限定名获取该类的二进制字节流的 `代码块` 叫做类加载器。 

`主要有一下四种类加载器:` 	

- 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。 
- 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 
- 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。 
- 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。

##### 20.简述java内存分配与回收策率以及Minor GC和Major GC 

1. 对象优先在堆的Eden区分配。 
2. 大对象直接进入老年代. 
3. 长期存活的对象将直接进入老年代. 当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.
   1. Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快;
   2. Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。 
